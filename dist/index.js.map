{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import { ActionTree, GetterTree, Module, ModuleTree, MutationTree, Plugin, Store, StoreOptions } from \"vuex\";\n\nconst useRootNamespace = { root: true }\n\nexport type MutationHandler<S, P> = (state: S, payload: P) => void\nexport type ActionHandler<S, R, G, P, T> = (context: BareActionContext<S, R, G>, payload: P) => Promise<T> | T\nexport type GetterHandler<S, R, G, T> = (state: S, getters: G, rootState: R) => T\ntype Promisify<T> = T extends PromiseLike<any> ? T : Promise<T>;\n\n\ninterface Dictionary<T> { [key: string]: T }\ninterface RootStore<R> extends Store<R> { rootGetters?: any }\n\nexport interface BareActionContext<S, R, G=any>\n{\n    state: S\n    rootState: R\n    getters: G\n}\n\nclass ModuleBuilderImpl<S, R={}, G=any> implements ModuleBuilder<S, R> {\n    protected _store: RootStore<R> | undefined\n\n    protected _getters: GetterTree<S, R> = {}\n    protected _mutations: MutationTree<S> = {}\n    protected _actions: ActionTree<S, R> = {}\n    protected _moduleBuilders: Dictionary<ModuleBuilder<any, R>> = {}\n\n    protected _vuexModule: Module<S, R> | undefined\n\n    constructor(public readonly namespace: string, private _initialState: S | null) { }\n\n    state(): () => S\n    {\n        if (!this.namespace)\n        {\n            return () => <any>this._store!.state as S\n        }\n        else if (this.namespace.indexOf(\"/\") < 0)\n        {\n            return () => (<any>this._store!.state)[this.namespace] as S\n        }\n        else\n        {\n            const namespaces = this.namespace.split(\"/\")\n            return () =>\n            {\n                let accessor: any = this._store!.state\n                for (const name of namespaces)\n                {\n                    accessor = accessor[name]\n                }\n                return (<any>accessor) as S\n            }\n        }\n    }\n\n    setInitialState(initialState: S): void\n    {\n        this._initialState = initialState\n    }\n\n    module<M>(namespace: string, initialState: M): ModuleBuilder<M, R>\n    module<M>(namespace: string): ModuleBuilder<M, R>\n    module<M>(namespace: string, initialState?: M): ModuleBuilder<M, R>\n    {\n        const existingModule = this._moduleBuilders[namespace]\n        const qualifiedNamespace = qualifyNamespace(this.namespace, namespace)\n        if (!initialState && existingModule)\n        {\n            return existingModule\n        }\n\n        // both arguments: create a module\n        if (existingModule && initialState)\n        {\n            existingModule.setInitialState(initialState)\n            return existingModule\n        }\n\n        const nestedBuilder = new ModuleBuilderImpl<M, R>(qualifiedNamespace, initialState || null)\n        this._moduleBuilders[namespace] = nestedBuilder\n        return nestedBuilder\n    }\n\n    commit<P>(handler: MutationHandler<S, void>): () => void\n    commit<P>(handler: MutationHandler<S, P>): (payload: P) => void\n    commit<P>(handler: MutationHandler<S, void>, name: string): () => void\n    commit<P>(handler: MutationHandler<S, P>, name: string): (payload: P) => void\n    commit<P>(handler: MutationHandler<S, P>, name?: string)\n    {\n        const { key, namespacedKey } = qualifyKey(handler, this.namespace, name)\n        if (this._mutations[key])\n        {\n            throw new Error(`There is already a mutation named ${key}.`)\n        }\n        this._mutations[key] = handler\n        return ((payload: P) => this._store!.commit(namespacedKey, payload, useRootNamespace)) as any\n    }\n\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, void>): () => Promise<void>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, void>): (payload: P) => Promise<void>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, T>): () => Promisify<T>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, T>): (payload: P) => Promisify<T>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, void>, name: string): () => Promise<void>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, void>, name: string): (payload: P) => Promise<void>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, T>, name: string): () => Promisify<T>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, T>, name: string): (payload: P) => Promisify<T>\n    dispatch<P, T>(handler: any, name?: string): any\n    {\n        const { key, namespacedKey } = qualifyKey(handler, this.namespace, name)\n        if (this._actions[key])\n        {\n            throw new Error(`There is already an action named ${key}.`)\n        }\n        this._actions[key] = handler\n        return (payload: P) => this._store!.dispatch(namespacedKey, payload, useRootNamespace)\n    }\n\n    read<T>(handler: GetterHandler<S, R, G, T>): () => T\n    read<T>(handler: GetterHandler<S, R, G, T>, name: string): () => T\n    read<T>(handler: GetterHandler<S, R, G, T>, name?: string): () => T\n    {\n        const { key, namespacedKey } = qualifyKey(handler, this.namespace, name)\n        if (this._getters[key])\n        {\n            throw new Error(`There is already a getter named ${key}.`)\n        }\n        this._getters[key] = handler\n        return () =>\n        {\n            if (this._store!.rootGetters)\n            {\n                return this._store!.rootGetters[namespacedKey] as T\n            }\n            return this._store!.getters[namespacedKey] as T\n        }\n    }\n\n    vuexModule(): Module<S, R>\n    {\n        if (!this._vuexModule)\n        {\n            // build nested modules recursively, if any\n            const modules: ModuleTree<R> = {}\n            for (const namespace of Object.keys(this._moduleBuilders))\n            {\n                modules[namespace] = this._moduleBuilders[namespace].vuexModule()\n            }\n\n            this._vuexModule = {\n                namespaced: true,\n                state: this._initialState || <S>{},\n                getters: this._getters,\n                mutations: this._mutations,\n                actions: this._actions,\n                modules\n            }\n        }\n        return this._vuexModule\n    }\n\n    _provideStore(store: Store<R>)\n    {\n        this._store = store\n\n        forEachValue(this._moduleBuilders, m => m._provideStore(store))\n    }\n}\n\nfunction qualifyKey(handler: Function, namespace: string | undefined, name?: string): { key: string, namespacedKey: string }\n{\n    const key: string = name || handler.name\n    if (!key)\n    {\n        throw new Error(`Vuex handler functions must not be anonymous. Possible causes: fat-arrow functions, uglify.  To fix, pass a unique name as a second parameter after your callback.`)\n    }\n    return { key, namespacedKey: qualifyNamespace(namespace, key) }\n}\n\nfunction qualifyNamespace(namespace: string | undefined, key: string)\n{\n    return namespace ? `${namespace}/${key}` : key\n}\n\nexport interface ModuleBuilder<S, R={}, G=any>\n{\n    /** The namespace of this ModuleBuilder */\n    readonly namespace: string\n\n    /** Creates a strongly-typed nested module within this module */\n    module<M>(namespace: string, initialState: M): ModuleBuilder<M, R>\n\n    /** Gets an existing nested module within this module */\n    module<M>(namespace: string): ModuleBuilder<M, R>\n\n    /** Set the initial state for an existing module */\n    setInitialState(initialState: S): void\n\n    /** Creates a strongly-typed commit function for the provided mutation handler */\n    commit<P>(handler: MutationHandler<S, void>): () => void\n    commit<P>(handler: MutationHandler<S, P>): (payload: P) => void\n    commit<P>(handler: MutationHandler<S, void>, name: string): () => void\n    commit<P>(handler: MutationHandler<S, P>, name: string): (payload: P) => void\n\n    /** Creates a strongly-typed dispatch function for the provided action handler */\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, void>): () => Promise<void>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, void>): (payload: P) => Promise<void>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, T>): () => Promisify<T>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, T>): (payload: P) => Promisify<T>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, void>, name: string): () => Promise<void>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, void>, name: string): (payload: P) => Promise<void>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, void, T>, name: string): () => Promisify<T>\n    dispatch<P, T>(handler: ActionHandler<S, R, G, P, T>, name: string): (payload: P) => Promisify<T>\n\n    /** Creates a strongly-typed read function for the provided getter function */\n    read<T>(handler: GetterHandler<S, R, G, T>): () => T\n    read<T>(handler: GetterHandler<S, R, G, T>, name: string): () => T\n\n    /** Creates a method to return this module's state */\n    state(): () => S\n\n    /** Output a Vuex Module definition. Called after all strongly-typed functions have been obtained */\n    vuexModule(): Module<S, R>\n\n    _provideStore(store: Store<R>): void\n}\n\nclass StoreBuilderImpl<R> extends ModuleBuilderImpl<any, R> {\n    constructor()\n    {\n        super(\"\", {})\n    }\n\n    module<S>(namespace: string, initialState: S): ModuleBuilder<S, R>\n    module<S>(namespace: string): ModuleBuilder<S, R>\n    module<S>(namespace: string, initialState?: S): ModuleBuilder<S, R>\n    {\n        return super.module(namespace, initialState) as ModuleBuilder<S, R>\n    }\n\n    vuexStore(): Store<R>\n    vuexStore(overrideOptions: StoreOptions<R>): Store<R>\n    vuexStore(overrideOptions: StoreOptions<R> = {}): Store<R>\n    {\n        if (!this._store)\n        {\n            const options: StoreOptions<R> & { namespaced?: boolean } = {\n                ...this.vuexModule(),\n                ...overrideOptions\n            }\n            const store = new Store<R>(options)\n            forEachValue(this._moduleBuilders, m => m._provideStore(store))\n            this._store = store\n        }\n        return this._store\n    }\n\n    registerModule(namespace: string): void\n    {\n        if (this._store && this._vuexModule) {\n            const mBuilder = this._moduleBuilders[namespace]\n            if (!mBuilder) throw 'fail to register module: ' + namespace\n            mBuilder._provideStore(this._store)\n\n            const vModule = mBuilder.vuexModule()\n            this._store.registerModule(namespace, vModule)\n\n            this._vuexModule.modules![namespace] = vModule\n        } else {\n            throw 'vuexStore hasn\\'t been called yet, use module() instead.'\n        }\n    }\n\n    reset()\n    {\n        this._store = undefined\n        this._moduleBuilders = {}\n    }\n}\n\nconst forEachValue = <T>(dict: Dictionary<T>, loop: (value: T) => any) =>\n{\n    Object.keys(dict).forEach(key => loop(dict[key]))\n}\n\nexport interface VuexStoreOptions<R>\n{\n    plugins?: Plugin<R>[]\n}\n\nexport interface StoreBuilder<R>\n{\n    /** Creates a ModuleBuilder for the namespace provided */\n    module<S>(namespace: string, state: S): ModuleBuilder<S, R>\n\n    /** Gets an existing ModuleBuilder for the namespace provided */\n    module<S>(namespace: string): ModuleBuilder<S, R>\n\n    /** Output a Vuex Store after all modules have been built */\n    vuexStore(): Store<R>\n\n    /** Output a Vuex Store and provide options, e.g. plugins -- these take precedence over any auto-generated options */\n    vuexStore(overrideOptions: StoreOptions<R>): Store<R>\n\n    /** Creates a strongly-typed commit function for the provided mutation handler */\n    commit<P>(handler: MutationHandler<R, void>): () => void\n    commit<P>(handler: MutationHandler<R, P>): (payload: P) => void\n    commit<P>(handler: MutationHandler<R, void>, name: string): () => void\n    commit<P>(handler: MutationHandler<R, P>, name: string): (payload: P) => void\n\n    /** Creates a strongly-typed dispatch function for the provided action handler */\n    dispatch<P, T>(handler: ActionHandler<R, R, void, void, void>): () => Promise<void>\n    dispatch<P, T>(handler: ActionHandler<R, R, void, P, void>): (payload: P) => Promise<void>\n    dispatch<P, T>(handler: ActionHandler<R, R, void, void, T>): () => Promisify<T>\n    dispatch<P, T>(handler: ActionHandler<R, R, void, P, T>): (payload: P) => Promisify<T>\n    dispatch<P, T>(handler: ActionHandler<R, R, void, void, void>, name: string): () => Promise<void>\n    dispatch<P, T>(handler: ActionHandler<R, R, void, P, void>, name: string): (payload: P) => Promise<void>\n    dispatch<P, T>(handler: ActionHandler<R, R, void, void, T>, name: string): () => Promisify<T>\n    dispatch<P, T>(handler: ActionHandler<R, R, void, P, T>, name: string): (payload: P) => Promisify<T>\n\n    /** Creates a strongly-typed read function for the provided getter function */\n    read<T>(handler: GetterHandler<R, R, void, T>): () => T\n    read<T>(handler: GetterHandler<R, R, void, T>, name: string): () => T\n\n    /** Creates a method to return the root state */\n    state(): () => R\n\n    /** Dynamically register module */\n    registerModule(namespace: string): void\n\n    /** WARNING: Discards vuex store and reset modules (non intended for end-user use) */\n    reset(): void\n}\n\nconst storeBuilderSingleton = new StoreBuilderImpl<any>()\nconst namedStoreBuilderMap: { [name: string]: StoreBuilderImpl<any> } = Object.create(null)\n\n/** Get a reference to the default store builder */\nexport function getStoreBuilder<R>(): StoreBuilder<R>\n/** Get a reference to a named store builder */\nexport function getStoreBuilder<R>(name: string): StoreBuilder<R>\nexport function getStoreBuilder<R>(name?: string): StoreBuilder<R>\n{\n    // the default store builder\n    if (!name)\n    {\n        return storeBuilderSingleton\n    }\n\n    // a named store builder\n    const builder = namedStoreBuilderMap[name] || (namedStoreBuilderMap[name] = new StoreBuilderImpl<R>())\n    return builder\n}\n"],"names":["Store"],"mappings":"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"}